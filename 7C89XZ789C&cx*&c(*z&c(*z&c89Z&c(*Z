#requires -version 5.1
$ErrorActionPreference = 'SilentlyContinue'
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# =========================
# BOOTSTRAP: LOGGING + UI
# =========================

# Paths
$BaseFolder = 'C:\VQW powershell tools.'
$LogDir     = Join-Path $BaseFolder 'Logs'
if (-not (Test-Path $LogDir)) { New-Item -ItemType Directory -Path $LogDir -Force | Out-Null }
$Timestamp  = Get-Date -Format 'yyyyMMdd_HHmmss'
$LogFile    = Join-Path $LogDir "SimmsPCChecker_$Timestamp.log"

# Logging function (console + file)
function Write-Log {
    param(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)][string]$Message,
        [ValidateSet('Info','Success','Warning','Error')][string]$Level = 'Info',
        [switch]$NoConsole
    )
    $ts = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
    $prefix = switch ($Level) {
        'Success' { '[SUCCESS]' }
        'Warning' { '[WARNING]' }
        'Error'   { '[ERROR]' }
        default   { '[INFO]' }
    }
    $line = "$ts $prefix $Message"
    if (-not $NoConsole) {
        switch ($Level) {
            'Success' { Write-Host $line -ForegroundColor Green }
            'Warning' { Write-Host $line -ForegroundColor Yellow }
            'Error'   { Write-Host $line -ForegroundColor Red }
            default   { Write-Host $line -ForegroundColor White }
        }
    }
    $line | Out-File -FilePath $LogFile -Append -Encoding UTF8
}

# Simple colored line
function Write-ColoredLine { param([string]$Text,[ConsoleColor]$Color='White'); $c=$Host.UI.RawUI.ForegroundColor; $Host.UI.RawUI.ForegroundColor=$Color; Write-Host $Text; $Host.UI.RawUI.ForegroundColor=$c }

# Enter-to-continue helper
function Wait-ForEnter {
    param([string]$PromptMessage="Press Enter to continue...")
    Write-ColoredLine $PromptMessage Yellow
    [void][Console]::ReadLine()
}

# Progress bar
function Show-ProgressBar {
    for ($i=0;$i -le 10;$i++) {
        $percent = $i*10
        $bar = ('#'*$i + '-'*(10-$i))
        Write-Host -NoNewline "`rProgress: [ $bar ] $percent% "
        Start-Sleep -Milliseconds 180
    }
    Write-Host ""
}

# =========================
# ASCII Header / Footer
# =========================

function Show-Header {
    $ascii = @(
        '  __   ____ ___      __ ',
        '  \ \ / / _` \ \ /\ / / ',
        '   \ V / (_| |\ V  V /  ',
        '    \_/ \__, | \_/\_/   ',
        '         |_|            '
    )
    Write-Host ""
    foreach ($line in $ascii) {
        Write-Host $line -ForegroundColor Yellow
    }
    Write-Host ""
}

function Show-Footer {
    $ascii = @(
        '  ____               ____             ',
        ' | __ ) _   _  ___  | __ ) _   _  ___ ',
        ' |  _ \| | | |/ _ \ |  _ \| | | |/ _ \',
        ' | |_) | |_| |  __/ | |_) | |_| |  __/',
        ' |____/ \__, |\___| |____/ \__, |\___|',
        '        |___/              |___/      '
    )
    Write-Host ""
    foreach ($line in $ascii) {
        Write-Host $line -ForegroundColor Yellow
    }
    Write-Host ""
}

# =========================
# Ensure Admin
# =========================
$IsAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()
).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
if (-not $IsAdmin) {
    Show-Header
    Write-Host ""
    Write-Host "[WARNING] This script is NOT running with Administrator privileges." -ForegroundColor Red
    Write-Host "[ACTION] Right-click PowerShell and select 'Run as Administrator'." -ForegroundColor Yellow
    Write-Log "Script not run as admin; exiting." -Level Error
    Pause
    exit 1
}

# Ensure base folder
if (-not (Test-Path $BaseFolder)) { New-Item -ItemType Directory -Path $BaseFolder -Force | Out-Null }

# WinAPI for maximize
Add-Type @"
using System;
using System.Runtime.InteropServices;
public class WinAPI {
    [DllImport("user32.dll")] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
}
"@
$SW_MAXIMIZE = 3

# Helper: Maximize by process
function Maximize-ByProcess {
    param([System.Diagnostics.Process]$Process)
    if (-not $Process) { return }
    for ($i=0;$i -lt 20;$i++){
        $Process.Refresh()
        if ($Process.MainWindowHandle -ne 0) { [WinAPI]::ShowWindow($Process.MainWindowHandle, $SW_MAXIMIZE) | Out-Null; break }
        Start-Sleep -Milliseconds 250
    }
}

# Helper: Download-and-extract if missing; otherwise reuse
function Ensure-Tool {
    param(
        [Parameter(Mandatory=$true)][string]$ZipUrl,
        [Parameter(Mandatory=$true)][string]$WorkFolder,
        [Parameter(Mandatory=$true)][string]$PrimaryExeName,
        [string]$ZipName = $(Split-Path $ZipUrl -Leaf)
    )
    $folder = Join-Path $BaseFolder $WorkFolder
    $zip    = Join-Path $BaseFolder $ZipName
    if (-not (Test-Path $folder)) { New-Item -ItemType Directory -Path $folder -Force | Out-Null }
    $exe = Get-ChildItem -Path $folder -Recurse -Filter $PrimaryExeName -ErrorAction SilentlyContinue | Select-Object -First 1
    if (-not $exe) {
        Write-Log "Downloading $WorkFolder from $ZipUrl"
        Invoke-WebRequest -Uri $ZipUrl -OutFile $zip -UseBasicParsing -ErrorAction Stop
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        [System.IO.Compression.ZipFile]::ExtractToDirectory($zip, $folder, $true)
        Remove-Item $zip -Force -ErrorAction SilentlyContinue
        $exe = Get-ChildItem -Path $folder -Recurse -Filter $PrimaryExeName -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($exe) { Write-Log "$WorkFolder extracted" -Level Success } else { Write-Log "$WorkFolder exe not found after extract" -Level Error }
    } else {
        Write-Log "$WorkFolder already present; skipping download" -Level Success
    }
    return $exe
}

# =========================
# INTRO BANNER + INFO
# =========================
Clear-Host
Show-Header
Write-ColoredLine "Welcome! Follow the on-screen instructions. Each step explains what to do." Yellow
Write-ColoredLine "All tools live in $BaseFolder. Logs: $LogFile" Yellow
Write-Host ""
